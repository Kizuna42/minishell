以下は、Minishellプロジェクトの評価項目です。

**Git repository**
* Gitリポジトリが学生またはグループに属しているかを確認する。
* 作業が関連するプロジェクトのものであることを確認し、「git clone」が空のフォルダで使用されていることを確認する。
* 悪意のあるエイリアスが使用されていないことを注意深く確認する。
* 評価する学生と評価される学生の両方が、採点を容易にするために使用される可能性のあるスクリプトを確認していることを注意深く確認する。
* 評価する学生がまだその特定のプロジェクトを完了していない場合、防御を開始する前にこの学生が主題全体を読むことが必須である。
* 空のリポジトリ、機能しないプログラム、規範エラー、チートなどを示すために、この評価で使用できるフラグを使用する。これらの場合、採点は終了し、最終成績は0点（チートの場合は-42点）となる。
* ただし、チートを除いて、作業について話し合い（たとえ終わっていなくても）、この失敗の原因となった可能性のある問題を特定し、将来同じ過ちを繰り返さないようにすることが推奨される。
* 防御期間中、セグメンテーションフォールト、その他の予期せぬ、時期尚早な、制御不能な、または予期せぬプログラムの終了がないこと。さもなければ最終成績は0点となる。適切なフラグを使用する。
* 設定ファイルが存在する場合を除き、ファイルを編集する必要はない。ファイルを編集したい場合は、評価される学生と理由を明確にし、両者がそれに同意していることを確認する。
* メモリリークがないことも確認する必要がある。ヒープに割り当てられたメモリは、実行終了前に適切に解放されなければならない。
* leaks、valgrind、e_fenceなど、コンピューターで利用可能なさまざまなツールを使用できる。
* メモリリークが発生した場合は、適切なフラグをチェックする。

**必須パート**

* **コンパイル**
    * `make -n` を使用して、コンパイルが `-Wall -Wextra -Werror` を使用しているかどうかを確認する。使用していない場合は、「invalid compilation flags」を使用する。
    * minishellがエラーなしでコンパイルされることを確認する。エラーがある場合はフラグを使用する。
    * makefileが再リンクしないこと。

* **単純なコマンドとグローバル変数**
    * `/bin/ls` のような絶対パスを持つ単純なコマンド、またはオプションなしの他のコマンドを実行する。
    * グローバル変数の数。その理由。なぜそれが必須または論理的だと感じるのか、具体的な例を挙げる。
    * 空のコマンドをテストする。
    * スペースまたはタブのみをテストする。
    * 何かクラッシュしたら、「crash flag」を使用する。
    * 何か機能しない場合は、「incomplete work flag」を使用する。

* **引数と履歴**
    * `/bin/ls` のような絶対パスを持つ単純なコマンド、または引数付きだが引用符や二重引用符なしの他のコマンドを実行する。
    * 異なるコマンドと引数で複数回繰り返す。
    * 何かクラッシュしたら、「crash flag」を使用する。
    * 何か機能しない場合は、「incomplete work flag」を使用する。

* **echo**
    * 引数ありまたはなし、あるいは `-n` を付けて `echo` コマンドを実行する。
    * 異なる引数で複数回繰り返す。
    * 何かクラッシュしたら、「crash flag」を使用する。
    * 何か機能しない場合は、「incomplete work flag」を使用する。

* **exit**
    * 引数ありまたはなしで `exit` コマンドを実行する。
    * 異なる引数で複数回繰り返す。
    * minishellを再起動するのを忘れないこと。
    * 何かクラッシュしたら、「crash flag」を使用する。
    * 何か機能しない場合は、「incomplete work flag」を使用する。

* **プロセスの戻り値**
    * `/bin/ls` のような絶対パスを持つ単純なコマンド、または引数付きだが引用符や二重引用符なしの他のコマンドを実行し、その後 `echo $?` を実行する。
    * 表示された値を確認する。bashで同じことを繰り返し、比較することができる。
    * `/bin/ls filethatdoesntexist` のような失敗するコマンドをいくつか使用して、異なるコマンドと引数で複数回繰り返す。
    * `expr $2+$2$` のようなもの。
    * 何かクラッシュしたら、「crash flag」を使用する。
    * 何か機能しない場合は、「incomplete work flag」を使用する。

* **シグナル**
    * 空のプロンプトで Ctrl-C を試すと、新しいプロンプトの新しい行が表示されるはずである。
    * 空のプロンプトで Ctrl-\ を試すと、何も起きないはずである。
    * 空のプロンプトで Ctrl-D を試すと、minishellが終了するはずである -> 再起動！
    * 何か入力した後のプロンプトで Ctrl-C を試すと、新しいプロンプトの新しい行が表示されるはずである。
    * 何か入力した後のプロンプトで Ctrl-D を試すと、何も起きないはずである。
    * 何か入力した後のプロンプトで Ctrl-\ を試すと、minishellが終了するはずである -> 再起動！
    * `cat` や引数なしの `grep` のようなブロックコマンドを実行した後で Ctrl-C を試す。
    * `cat` や引数なしの `grep` のようなブロックコマンドを実行した後で Ctrl-\ を試す。
    * `cat` や引数なしの `grep` のようなブロックコマンドを実行した後で Ctrl-D を試す。
    * 異なるコマンドで複数回繰り返す。
    * 何かクラッシュしたら、「crash flag」を使用する。
    * 何か機能しない場合は、「incomplete work flag」を使用する。

* **二重引用符**
    * 引数付きだが、今回は二重引用符（空白を含むべき）で単純なコマンドを実行する。
    * `echo "cat lol.c | cat > lol.c"` のようなコマンド。
    * `$` 以外。
    * 何かクラッシュしたら、「crash flag」を使用する。
    * 何か機能しない場合は、「incomplete work flag」を使用する。

* **単一引用符**
    * 引数として単一引用符付きでコマンドを実行する。
    * 空の引数を試す。
    * 単一引用符内で環境変数、空白、パイプ、リダイレクションを試す。
    * `echo '$USER'` は `$USER` と表示されるはずである。
    * 何も解釈されないはずである。

* **env**
    * `env` が現在の環境変数を表示するかどうかを確認する。

* **export**
    * 環境変数をエクスポートし、新しいものを作成し、古いものを置き換える。
    * `env` でそれらを確認する。

* **unset**
    * 環境変数をエクスポートし、新しいものを作成し、古いものを置き換える。
    * それらのいくつかを削除するために `unset` を使用する。
    * 結果を `env` で確認する。

* **cd**
    * `cd` コマンドを使用して作業ディレクトリを移動し、`ls` で正しいディレクトリにいることを確認する。
    * 動作する `cd` と動作しない `cd` で複数回繰り返す。
    * 引数として `.` `..` も試す。

* **pwd**
    * `pwd` コマンドを使用する。
    * 複数のディレクトリで複数回繰り返す。

* **相対パス**
    * 今回は相対パスを使用してコマンドを実行する。
    * 複雑な相対パス（たくさんの `..`）で複数のディレクトリで複数回繰り返す。

* **環境パス**
    * 今回はパスなしでコマンドを実行する（`ls`, `wc`, `awk` など）。
    * `$PATH` を解除し、機能しなくなることを確認する。
    * `$PATH` を複数のディレクトリ値（directory1:directory2）に設定し、ディレクトリが左から右へ順にチェックされることを確認する。

* **リダイレクション**
    * `<` および/または `>` のリダイレクションを使用してコマンドを実行する。
    * 異なるコマンドと引数で複数回繰り返し、時々 `>` を `>>` に変更する。
    * 同じリダイレクションが複数ある場合に失敗することを確認する。
    * `<<` リダイレクションをテストする（履歴を更新する必要はない）。

* **パイプ**
    * `cat file | grep bla | more` のようなパイプ付きコマンドを実行する。
    * 異なるコマンドと引数で複数回繰り返す。
    * `ls filethatdoesntexist | grep bla | more` のような失敗するコマンドをいくつか試す。
    * パイプとリダイレクションを混ぜて試す。

* **Go Crazy and history**
    * コマンドラインを入力し、Ctrl-C を押してから Enter キーを押すと、バッファがクリアされ、何も実行されないはずである。
    * 上下キーで履歴をナビゲートし、いくつかのコマンドを再試行できるか。
    * `dsbksdgbksdghsd` のように機能しないコマンドを実行し、シェルがクラッシュせず、エラーを出力することを確認する。
    * 非常に多くの引数を持つ長いコマンドを実行する。
    * この美しいミニシェルを楽しんでください。

* **環境変数**
    * いくつかの `$` 変数を引数として `echo` を実行する。
    * `$` が環境変数として解釈されることを確認する。
    * 二重引用符が `$` を展開することを確認する。
    * `$USER` が存在するか、設定されていることを確認する。
    * `echo "$USER"` は `$USER` の値を表示するはずである。

**ボーナス**

* **And, Or**
    * `&&`、`||`、および括弧をコマンドとともに使用し、bashと同じように機能することを確認する。

* **ワイルドカード**
    * ローカルディレクトリの引数にワイルドカードを使用する。

* **サプライズ（またはそうでない…）**
    * `USER` 環境変数を設定する。
    * `echo "$USER"` をテストする。これは `'USER_VALUE'` を出力するはずである。
    * `echo '$USER'` をテストする。これは `"$USER"` を出力するはずである。

**評価**
防御に対応するフラグをチェックするのを忘れないこと。
* Ok
* Outstanding project
* Empty work
* No author file
* Invalid compilation
* Norme
* Cheat
* Crash
* Leaks
* Forbidden function

**結論**
